use regex::Regex;
use serde::{Deserialize, Serialize};
use std::io::BufRead;
use std::io::BufReader;
use std::string::String;
use tree_sitter::Parser;

/*
{
    "hexsha": "6d0e57bca09d3b30c611968b1f86654d988cc549",
    "size": 6416,
    "ext": "py",
    "lang": "Python",

    "max_stars_repo_path": "preprocessing.py",
    "max_stars_repo_name": "YuanZi1501040205/Ice-detection-for-smart-track-heating-with-normal-only-self-supervised-learning",
    "max_stars_repo_licenses": ["MIT"],
    "max_stars_count": null,

    "max_forks_repo_path": "preprocessing.py",
    "max_forks_repo_name": "YuanZi1501040205/Ice-detection-for-smart-track-heating-with-normal-only-self-supervised-learning",
    "max_forks_repo_licenses": ["MIT"],
    "max_forks_count": null,
}
*/

#[derive(Serialize, Deserialize)]
struct TheStackMetadata {
    lang: String,
    #[serde(rename(deserialize = "max_stars_repo_path"))]
    path: String,
    #[serde(rename(deserialize = "max_stars_repo_name"))]
    repo_name: String,
    #[serde(rename(deserialize = "max_stars_repo_licenses"))]
    repo_licenes: Vec<String>,
    #[serde(rename(deserialize = "max_stars_count"))]
    repo_stars: Option<f32>,
}

#[derive(Serialize, Deserialize)]
struct TheStackDocument {
    #[serde(rename(deserialize = "content"))]
    text: String,
    #[serde(flatten)]
    metadata: TheStackMetadata,
}

fn get_alpha_num_ratio(text: &String) -> f32 {
    let mut numeric_chars = 0.0;
    let mut total_chars = 0.0;
    for c in text.chars() {
        total_chars += 1.0;
        if c.is_numeric() {
            numeric_chars += 1.0;
        }
    }
    numeric_chars / total_chars
}

fn _print_tree(node: &tree_sitter::Node, depth: usize) {
    if depth > 3 {
        return;
    }
    let indentation = "  ".repeat(depth);
    println!(
        "{}{}: {}",
        indentation,
        node.kind(),
        node.range().start_byte
    );

    for child in node.children(&mut node.walk()) {
        _print_tree(&child, depth + 1);
    }
}

fn get_copyright(tree: &tree_sitter::Tree, source_code: &String) -> anyhow::Result<i32> {
    //let (mut s, mut e) = (-1, -1);
    let mut multiline_comment = String::from("");
    let mut end_of_comment = -1;
    for child in tree.root_node().children(&mut tree.root_node().walk()) {
        if child.kind() == "comment" {
            if end_of_comment != child.range().start_byte as i32 - 1 && multiline_comment != "" {
                if multiline_comment.to_lowercase().contains("copyright") {
                    println!("{}", multiline_comment);
                    println!("");
                }
                multiline_comment = String::from("");
            }
            multiline_comment += "\n";
            multiline_comment += child.utf8_text(source_code.as_bytes())?;
            end_of_comment = child.range().end_byte as i32;
        }
    }
    /*if multiline_comment != "" && multiline_comment.to_lowercase().contains("copyright"){
    println!("{}", multiline_comment);
    }*/
    Ok(0)
}

struct TheStackMetrics {
    n_functions: i32,
    length_functions: i32,
}

impl Default for TheStackMetrics {
    fn default() -> Self {
        TheStackMetrics {
            n_functions: 0,
            length_functions: 0,
        }
    }
}

fn print_parse_tree(code_text: &String) -> anyhow::Result<()> {
    let mut parser = Parser::new();
    parser
        .set_language(tree_sitter_java::language())
        .expect("Error loading Python grammar");

    let tree = parser.parse(code_text, None).unwrap();
    let mut stats: TheStackMetrics = Default::default();
    for child in tree.root_node().children(&mut tree.root_node().walk()) {
        println!(
            "{}, {}->{}",
            child.kind(),
            child.range().start_byte,
            child.range().end_byte
        );
        if child.kind() == "function_definition" {
            stats.length_functions += (child.range().end_byte - child.range().start_byte) as i32;
            stats.n_functions += 1;
        }
    }
    Ok(())
}

pub fn process_thestack() -> anyhow::Result<()> {
    let buf_stdin = BufReader::new(std::io::stdin());
    let re = Regex::new(r"[Gg]enerated by")?;

    for document in buf_stdin.lines() {
        let document = document?;
        let mut document: TheStackDocument = serde_json::from_str(&document)?;
        let alpha_num_ratio = get_alpha_num_ratio(&document.text);
        let repo_stars = match document.metadata.repo_stars {
            Some(i) => i,
            None => 0.0,
        };
        let is_autogenerated = match re.find(&document.text) {
            Some(m) => m.start() < 400,
            None => false,
        };
        if alpha_num_ratio < 0.2 && repo_stars > 10.0 && !is_autogenerated {
            document.text = document.text.replace("\r\n", "\n");
            //println!("{}", serde_json::to_string(&document).expect("yolo"));
            //println!("{}", document.text);
        }
        print_parse_tree(&document.text)?;
        //println!("{}", document.text);
    }

    Ok(())
}
